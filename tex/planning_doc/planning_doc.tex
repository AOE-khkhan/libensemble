\documentclass{article}

\usepackage{amsmath, amsfonts, amssymb, setspace, color, graphicx}%psfrag}%,pstool}
\usepackage[american]{babel}
\usepackage[normalem]{ulem} % For \sout
\usepackage{fullpage}
\everymath{\displaystyle}
\usepackage[ruled,vlined]{algorithm2e}

\newenvironment{allintypewriter}{\ttfamily}{\par}
\newcommand{\jlnote}[1]{\textsf{{\color{blue}{ JL note:}   #1.} }\marginpar{{\textbf{Comment}}}}
\newcommand{\ps}[1]{\ensuremath{\mathtt{#1}}}

\title{LibEnsemble planning document}


\begin{document}
\maketitle
\begin{abstract}
  This document will be an explicit plan of what will be developed in
  LibEnsemble. Proper planning should help ensure that the code will be flexible
  and easy to adjust in the future.

  Current development considers a manager and worker framework. 
\end{abstract}
\section{Questions}
\begin{itemize}
  \item How many resources to give to $\mathtt{gen}$?
\end{itemize}

In order to ensure applicability to a variety of use cases, 
LibEnsemble will coordinate many different types of calculations. Examples of
such calculations include:
\begin{itemize}
  \item Simulation evaluations
  \item Generation of point(s) to be evaluated by the simulation(s)
  \item Updating points in the active queue
  \item Updating active simulations
  \item Monitoring intermediate output from simulations
\end{itemize}
Users will only need to provide scripts for simulation evaluation and point
generation. We will provide default scripts for the other types of calculations, 
which can be templates for the interested user. As a default the Manager will
perform many calculations itself (essentially blocking the manager), but we can
possibly monitor this and adjust as needed if manager-calculations are
expensive. 

\subsection{Manager}
\begin{itemize}
  \item Generates inputs for calculations.
    \begin{itemize}
      \item If the calculation is a simulation, determine parameters to be
        evaluated.
      \item If the calculation is a local optimization run, give state
        information for determining the next point in a run. 
      \item If the calculation is deciding where to start a run, then give all
        evaluated (and about-to-be-evaluated) points.
    \end{itemize}
  \item Launches calculations
    \begin{itemize}
      \item Possibly resume previously paused calculations
    \end{itemize}
  \item Received output from calculations
    \begin{itemize}
      \item Possibly receive intermediate output
    \end{itemize}
  \item Coordinates concurrent calculations 
    \begin{itemize}
      \item Dynamic queue of pending calculations
      \item Possibly monitor sims
    \end{itemize}
  \item Tracks history of calculations
  \item Allocated resource to calculations 
    \begin{itemize}
      \item Possibly changes resources during calculations (or just simulations)
    \end{itemize}
  \item Tolerates failed calculations (or just simulations)
    \begin{itemize}
      \item Possibly without losing the resource when possible
    \end{itemize}
  \item Can exploit persistent data
    \begin{itemize}
      \item For example: checkpointing, meshes, iterative solvers
    \end{itemize}
  \item Can gracefully terminate calculations
    \begin{itemize}
      \item Possibly pause
    \end{itemize}
\end{itemize}

If we are going to keep everything general, then perhaps we require a
calculation-type-dependent user-defined function to be called before and after
after every type of calculation.

\subsection{Worker}
\begin{itemize}
  \item Performs the calculations given to it.
\end{itemize}


\section{Pseudocode}

\newpage
\LinesNumbered
\begin{algorithm}[t] % Makes font smaller
% \begin{algorithm}[H] % Makes font larger
  \SetKwComment{Comment}{$\triangleright$\ }{}
  \SetAlgoNlRelativeSize{-5}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Optional}{optional}
  \SetKwInOut{Output}{output}
  \SetKw{true}{true}
  \SetKw{false}{false}
  \Input{Simulations $\mathtt{sim}_1,\ldots,\mathtt{sim}_{n_s}$, \newline
         Point generating function $\mathtt{gen}$, \newline
         $c$ workers
  }
  \Optional{Termination test $\mathtt{term\_test}$ \newline
            Active simulation and queue update function $\mathtt{update\_active\_and\_queue}$ \newline
            Function to decide resources to be used for each sim evaluation $\mathtt{decide\_resources}$
  }
  Initialize history $H$ (past and current calculations)\\
  Initialize queue $Q$ (values and resources for to-be-evaluated points) 

  \For{$i \in \left\{ 1,\ldots,c \right\}$}{
  Initialize worker $i$ on $\mathtt{gen}(H,Q)$\\
  }
  
  \While{$\mathtt{term\_test}(H,Q)$}
  {
    \While{Any worker is waiting to return $\mathtt{sim}$ or $\mathtt{gen}$ results} 
    {
      Receive from all workers with $\mathtt{sim}$ and $\mathtt{gen}$ work\\
    }

    $(H,Q) = \mathtt{update\_active\_and\_queue}(H,Q)$\Comment*[r]{blocks manager}
    $Q = \mathtt{decide\_resources}(H,Q)$\Comment*[r]{blocks manager}

    \For{Each idle worker $i$}
    {
      \eIf{ $Q \neq \emptyset$}
      {
      Tell worker $i$ to evaluate $\mathtt{sim}_j$ at point(s) from $Q$ with appropriate resources
      }{
      Begin worker $i$ on $\mathtt{gen}(H,Q)$\\
      }
    }
  }
  Receive from (kill?) active workers\\ 
  Terminate all workers
  \caption{LibEnsemble manager logic \label{alg:manager}} 
\end{algorithm}

\newpage
\LinesNumbered
\begin{algorithm}[t] % Makes font smaller
% \begin{algorithm}[H] % Makes font larger
  \SetKwComment{Comment}{$\triangleright$\ }{}
  \SetAlgoNlRelativeSize{-5}
  \SetKwInOut{Input}{input}
  \SetKwInOut{Optional}{optional}
  \SetKwInOut{Output}{output}
  \SetKw{true}{true}
  \SetKw{false}{false}
  \Input{Simulation parameters $\mathtt{sim}_1,\ldots,\mathtt{sim}_{n_s}$, \newline
         generating function $\mathtt{gen}$, \newline
         $c$ workers
  }
  % \Optional{Termination test $\mathtt{term\_test}$ \newline
  %           Active simulation and queue update function $\mathtt{update\_active\_and\_queue}$ \newline
  %           Function to decide resources to be used for each sim evaluation $\mathtt{decide\_resources}$
  % }

  \SetKw{break}{break}
  \SetKw{break}{break}
  Initialize own simulation directory (if necessary) and generating directory (if necessary)\\
  \While{\true}
  {
    $D =$ Receive from manager \\ 
    \If{$D.tag == \mathtt{stop\_tag}$ }{\break}

    \If{$D.form\_subcomm$ is nonempty}{Form subcommunicator $sc$ with other workers}

    $D.calc\_f(sc, D.calc\_params)$
    
  }
  Terminate all workers
  \caption{Each LibEnsemble worker's logic \label{alg:manager}} 
\end{algorithm}

\section{API}

\begin{allintypewriter}
  libE(c, history, allocation\_specs, sim\_specs, failure\_processing,
  exit\_criteria)\\



  \begin{description}
    \item[c]: [dictionary] 
      \begin{description}
        \item['comm']: [mpi4py communicator] to be used by libE
        \item['color']: [int] communicator color
      \end{description}

    \item[history]: [numpy structured array] 
      \begin{description}
        \item[x]: parameters given to simulations
        \item[f]: simulation value(s) at each x
        \item[...]:
        \item[...]:
      \end{description}

    \item[allocation\_specs]: [dict]
      \begin{description}
        \item[manager\_ranks]: [python set of ints] 
        \item[lead\_worker\_ranks]: [python set of ints]
        \item[machinefile]:
      \end{description}

    \item[sim\_specs]: [dict of dicts] one dict for each simulation.
      \begin{description}
        \item[sim\_f]: [func] that calls sim
        \item[sim\_f\_params]: [dict] parameters for sim\_f
        \item[n]: [int] dimension of simulation parameters
        \item[m]: [int] dimension of simulation output 
        \item[data]: 
        \item[gen\_f]: [func] generates next points to be evaluated by a sim
        \item[gen\_f\_params]: [dict] parameters for gen\_f
        \item[lb]: [n-by-1 array] lower bound on sim parameters
        \item[ub]: [n-by-1 array] upper bound on sim parameters
      \end{description}
      Possible fields of a local optimization's dict:
      - various tolerances and settings 

    \item[failure\_processing]: [dict]


    \item[exit\_criteria]: [dict] with possible fields:
      \begin{description}
        \item[sim\_eval\_max]: [int] Stop after this many evaluations.
        \item[min\_sim\_f\_val]: [dbl] Stop when a value below this has been found.
      \end{description}
  \end{description}
\end{allintypewriter}
        




\section{List of items to develop.}



\section{Target problems}
There are many types of simulations that we can consider being run in LibEnsemble.

\begin{enumerate}
  \item A Python function
    \begin{itemize}
      \item We assume this is thread-safe.
      \item Use cases: 
        \begin{itemize}
          \item ??
        \end{itemize}
    \end{itemize}
  \item An executable
    \begin{itemize}
      \item May use MPI
      \item Must perform evaluations in a manner that won't conflict with other evaluations. 
        \begin{itemize}
          \item Performs read/writes in the directory where it is run (or in a given directory)
        \end{itemize}
      \item Must be able to tell executable where to run.
        \begin{itemize}
          \item MCS compute node: Can specify CPU
          \item Blues: Can specify machinefile
          \item Mira: Not going to be addressed at this time.
          \item Theta/Aurora: ?
          \item Cray system: ?
        \end{itemize}
      \item Use case: 
        \begin{itemize}
          \item OPAL accelerator simulation [John Power and Nicole Neveu]
          \item LAMMPS simulation [Simon Phillpot and Eugene Ragasa]
        \end{itemize}
    \end{itemize}
  \item An MPI simulation with a subcommunicator
    \begin{itemize}
      \item Possibly stops regularly to communicate with manager
      \item Use cases: 
        \begin{itemize}
          \item ??
        \end{itemize}
    \end{itemize}
  \item PETSc simulation 
    \begin{itemize}
      \item Access to complete memory stack
      \item Easier to kill/monitor?
      \item Use cases: 
        \begin{itemize}
          \item ??
        \end{itemize}
    \end{itemize}
\end{enumerate}



% \bibliographystyle{plain}
% \bibliography{article}
\end{document} 
